[H1] 05 Orchestrate multi-agent solution using Semantic Kernel## ProblemYou need address complex DevOps challenges, as:- Monitoring application performance- Detecting analyzing issues- Deploying automated fixes- Reporting outcomes stakeholdersSingle agents may suffice tasks. A collaborative multi-agent system required divide responsibilities orchestrate solutions effectively.## Solution Azure Semantic KernelUse Semantic Kernel SDK create multi-agent architecture several AI agents collaborate within conversation using Semantic Kernel Agent Framework. These agents operate independently yet work together shared chat interface can:- Analyze logs- Correlate events- Trigger actions (e.g., via CI/CD)- Notify users reportsThe Agent Framework Semantic Kernel provides architecture top existing Semantic Kernel resources, including:-Agents: Agents intelligent, AI-driven entities capable reasoning executing tasks. They use language models, functions, memory make decisions dynamically.-Agent
Semantic Kernel resources, including:-Agents: Agents intelligent, AI-driven entities capable reasoning executing tasks. They use language models, functions, memory make decisions dynamically.-Agent collaboration: Agents collaborate together agent group chat, enables multiple agents join chat, even different agent types. Agent group chats determine agent respond determine conversation finished.## Semantic Kernel Features:They also still available within Agent Framework, including:1.Kernel: The kernel central component Semantic Kernel. The kernel acts execution engine, managing AI interactions, function orchestration, memory.2.Tools plugins: Plugins align existing Semantic Kernel features, enabling agents dynamically interact external services execute complex tasks function calling. Within Agent Framework, tools available provide extra functionality agents, file searching code interpreter, similar tool usage Azure AI Foundry Agent Service. Agents use tools plugins perform specific
Agent Framework, tools available provide extra functionality agents, file searching code interpreter, similar tool usage Azure AI Foundry Agent Service. Agents use tools plugins perform specific tasks.3.History: Agents maintain chat history across multiple interactions, allowing track previous interactions adapt responses accordingly. The conversation history always accessible agents, either whole specific agent's chat history.### Types agents:The Semantic Kernel Agent Framework supports several different types agents, including:1.Azure AI Agent: specialized agent within Semantic Kernel Agent Framework. The AzureAIAgent type designed provide advanced conversational capabilities seamless tool integration. It automates tool calling securely manages conversation history using threads, reducing overhead maintaining state. The AzureAIAgent also supports variety built-in tools, including file retrieval, code execution, data interaction via Bing, Azure AI Search, Azure Functions,
reducing overhead maintaining state. The AzureAIAgent also supports variety built-in tools, including file retrieval, code execution, data interaction via Bing, Azure AI Search, Azure Functions, OpenAPI.2.Chat Completion Agent: designed chat completion conversation interfaces. The ChatCompletionAgent type mirrors features patterns underlying AI Service support natural language processing, contextual understanding, dialogue management.3.OpenAI Assistant Agent: designed advanced capabilities multi-step tasks. The OpenAIAssistantAgent type supports goal-driven interactions additional features like code interpretation file search.## Core concepts:### 1. Create AgentGroupChat:A key feature Semantic Kernel Agent Framework ability facilitate interactions multiple agents. Using AgentGroupChat, developers create dynamic, multi-agent conversations different types agents collaborate generate responses.The AgentGroupChat class extends AgentChat framework, providing structured way manage
developers create dynamic, multi-agent conversations different types agents collaborate generate responses.The AgentGroupChat class extends AgentChat framework, providing structured way manage multi-agent collaboration. It offers built-in mechanisms control conversation flow, define collaboration strategies, support single-turn multi-turn interactions.### 2. Add messages chatOnce chat created, create ChatMessageContent object add chat thread. The ChatMessageContent object takes role parameter addition content.### 3. Conversation Modes AgentGroupChatAgent group chats operate two distinct modes, depending conversation requirements:-In single-turn conversations, designated agent provides response based user input.1.Intent recognition: The framework analyzes user's query identify intent match relevant agent.2.Predefined rules: Developers configure routing rules direct specific queries designated agents application.You invoke response single-turn chat usingAgentGroupChat.invokespecifying
relevant agent.2.Predefined rules: Developers configure routing rules direct specific queries designated agents application.You invoke response single-turn chat usingAgentGroupChat.invokespecifying agent respond.-In multi-turn conversations, multiple agents take turns responding, continuing conversation termination condition met.Agent responses returned asynchronously generated, allowing conversation unfold real-time.1.Context tracking: The framework maintains record conversation history understand user's intent select appropriate agent.2.Dynamic switching: If topic shifts, framework dynamically switches agent specializing new domain middle conversation.You invoke response multi-turn chat usingAgentGroupChat.invoke.Both modes allow agents collaborate building other's responses, resulting dynamic, intelligent interactions.### 4. Design agent selection strategyOne key feature Semantic Kernel Agent Framework support intelligent, multi-agent interactions. Agent collaboration achieved
dynamic, intelligent interactions.### 4. Design agent selection strategyOne key feature Semantic Kernel Agent Framework support intelligent, multi-agent interactions. Agent collaboration achieved using AgentGroupChat, critical components consider necessary single agents non-agentic Semantic Kernel applications.It's important choose agent that's best suited respond user's query, especially multi-agent systems agents specialize different domains.For multi-turn agents, agent selection determined selection strategy. The selection strategy defined within framework, either using predefined selection strategy extending SelectionStrategy class define custom selection behavior. You define selection strategy create AgentGroupChat object.1.SequentialSelectionStrategy: TheSequentialSelectionStrategy classoffers predefined selection strategy agent turn order based order agents added chat. The option specify initial agent also
object.1.SequentialSelectionStrategy: TheSequentialSelectionStrategy classoffers predefined selection strategy agent turn order based order agents added chat. The option specify initial agent also available.KernelFunctionSelectionStrategy2.KernelFunctionSelectionStrategy: TheKernelFunctionSelectionStrategy classallows define selection strategy creating kernel function prompt. In writer reviewer example, selection strategy prompt might be:If preferred interaction always certain agent respond first, specified selection strategy seen prompt above.3.SelectionStrategy base class: TheSelectionStrategy base classcontains overridable select_agent method define custom logic selecting next agent. The return value must agent present group chat.Once decide selection strategy, assign selection_strategy parameter AgentGroupChat object.Truncating chat historySince selection strategy typically rely last message chat determine next agent, truncate chat history reduce token usage help improve
parameter AgentGroupChat object.Truncating chat historySince selection strategy typically rely last message chat determine next agent, truncate chat history reduce token usage help improve performance. The KernelFunctionSelectionStrategy accepts history_reducer parameter specify as:pythonhistory_reducer = ChatHistoryTruncationReducer(target_count=1)### 5. Define chat termination strategyMulti-turn conversations responses returned asynchronously, conversation develop naturally. However, agents need know stop conversation, determined termination strategy.Termination strategyA termination strategy ensures conversations tasks conclude appropriately. This strategy prevents unnecessary messages user, limits resource usage, improves overall user experience.Similar selection strategy specified, developers define termination strategy use predefined strategy. Each termination strategy supports maximum_iterations parameter end chat maximum number iterations. The default value 99 iterations. Each
define termination strategy use predefined strategy. Each termination strategy supports maximum_iterations parameter end chat maximum number iterations. The default value 99 iterations. Each termination strategy also requires agents run strategy. In writer-reviewer agent scenario, ReviewingDirectorAgent determine chat terminate.1.DefaultTerminationStrategy: TheDefaultTerminationStrategy classterminate specified number maximum iterations.2.KernelFunctionTerminationStrategy: TheKernelFunctionTerminationStrategy classallows define termination strategy creating kernel function prompt. This class requires result_parser parameter. The result_parser function processes output prompt function determine whether termination condition met. It takes output prompt function processes return True False.3.TerminationStrategy base class: TheTerminationStrategy base classcontains overridable should_agent_terminate method define custom logic concluding agent group chat. The return value must Boolean. For
base class: TheTerminationStrategy base classcontains overridable should_agent_terminate method define custom logic concluding agent group chat. The return value must Boolean. For example, could define termination function checks recent history entry word "yes", however would need provide explicit instructions agent return termination keyword.Once decided termination strategy, assign termination_strategy parameter AgentGroupChat object.Truncating chat historySince termination strategy typically rely last message chat determine whether chat terminate, truncate chat history reduce token usage help improve performance. The KernelFunctionTerminationStrategy accepts history_reducer parameter specify as:pythonhistory_reducer = ChatHistoryTruncationReducer(target_count=1)Conversation stateWhether use AgentGroupChat single-turn multi-turn conversation, state updates completed meets termination criteria. However, may want use group chat instance again. To keep using chat instance, need reset
use AgentGroupChat single-turn multi-turn conversation, state updates completed meets termination criteria. However, may want use group chat instance again. To keep using chat instance, need reset completion state False. Without state reset, AgentGroupChat can't accept new interactions.When conversation hits maximum number iterations allowed, conversation end marked completed. In case, extend conversation without resetting conversation state.By understanding components, better utilize Semantic Kernel Agent Framework build intelligent multi-agent systems.## Required Components- Semantic Kernel SDK- Semantic Kernel Agent Framework- AzureAIAgent, ChatCompletionAgent, OpenAIAssistantAgent- Agent types different roles (e.g., Monitoring, Deployment, Reporting)- Tools/plugins support (e.g., file search, OpenAPI, Azure Functions)- Chat management classes: AgentGroupChat, ChatMessageContent, etc.## Architecture / Development### Fondamentals:-Agents: Autonomous entities powered language models
search, OpenAPI, Azure Functions)- Chat management classes: AgentGroupChat, ChatMessageContent, etc.## Architecture / Development### Fondamentals:-Agents: Autonomous entities powered language models + traditional code.-Agent Collaboration: Enabled via AgentGroupChat.-Kernel: Core executor handling memory, orchestration, tools.-Tools & Plugins: Functions external APIs action execution.-History: Persistent chat memory available across interactions.### Core concepts:1.Create AgentGroupChatInitialize group chat coordinate multiple agents shared conversation.2.Add messages chatInsert initial ongoing messages drive agent interactions.3.Conversation Modes AgentGroupChatChoose agents interacte.g., single-turn, multi-turn.4.Design agent selection strategyDefine logic select agent respond message.5.Define chat termination strategySet rules ending conversation, like reaching goal max turns.### 1. Create AgentGroupChatpython# Define agentsagent_writer = AzureAIAgent(...)agent_reviewer =
message.5.Define chat termination strategySet rules ending conversation, like reaching goal max turns.### 1. Create AgentGroupChatpython# Define agentsagent_writer = AzureAIAgent(...)agent_reviewer = AzureAIAgent(...)# Create chatchat = AgentGroupChat(agents=[agent_writer, agent_reviewer])Or dynamically:pythonchat = AgentGroupChat()chat.add_agent(agent=agent_writer)chat.add_agent(agent=agent_reviewer)### 2. Add messages chatpythonchat_message = ChatMessageContent(role=AuthorRole.USER, content="This message content.")await chat.add_chat_message(message=chat_message)### 3. Conversation Modes AgentGroupChatSingle-turn:pythonasync message chat.invoke(agent): # Process responseMulti-turn:pythonasync message chat.invoke(): # Process responses multiple agents### 4. Design agent selection strategyChoose responds next multi-agent chat:-KernelFunctionSelectionStrategy: Uses custom prompt determine next agent.Example prompt:```pythonprompt=f"""Determine next agent:Participants:-
strategyChoose responds next multi-agent chat:-KernelFunctionSelectionStrategy: Uses custom prompt determine next agent.Example prompt:```pythonprompt=f"""Determine next agent:Participants:- ReviewingDirectorAgent- CopywriterAgentRules:- After user input -
